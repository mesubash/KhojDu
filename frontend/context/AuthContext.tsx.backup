"use client"

// Auth Context - Global authentication state management
// ✅ SECURITY: Access token stored in memory only, refresh token in HTTP-only cookie

import React, { createContext, useContext, useState, useEffect, useCallback } from "react"
import { useRouter } from "next/navigation"
import authService from "@/services/authService"
import type {
  User,
  LoginRequest,
  RegisterRequest,
  AuthState,
  ApiResponse,
  LoginResponse,
  RegisterResponse,
} from "@/types/auth"

interface AuthContextType extends AuthState {
  login: (credentials: LoginRequest) => Promise<void>
  register: (userData: RegisterRequest) => Promise<void>
  logout: () => Promise<void>
  refreshAuth: () => Promise<void>
  clearError: () => void
  setAccessToken: (token: string | null) => void
}

const AuthContext = createContext<AuthContextType | null>(null)

interface AuthProviderProps {
  children: React.ReactNode
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [state, setState] = useState<AuthState>({
    user: null,
    isAuthenticated: false,
    isLoading: true,
    error: null,
  })

  const router = useRouter()

  // Initialize auth state on mount - verify session with backend
  useEffect(() => {
    const initAuth = async () => {
      try {
        // Call /me endpoint to verify session (backend checks cookies automatically)
        const response = await authService.getCurrentUser()
        
        if (response.data) {
          setState({
            user: response.data,
            isAuthenticated: true,
            isLoading: false,
            error: null,
          })
          console.log('[AuthContext] ✅ Session verified')
        } else {
          setState({
            user: null,
            isAuthenticated: false,
            isLoading: false,
            error: null,
          })
        }
      } catch (error: any) {
        // No valid session
        console.log('[AuthContext] No active session')
        setState({
          user: null,
          isAuthenticated: false,
          isLoading: false,
          error: null,
        })
      }
    }

    initAuth()
  }, [])



  // Login handler
  const login = useCallback(
    async (credentials: LoginRequest) => {
      setState((prev) => ({ ...prev, isLoading: true, error: null }))

      try {
        console.log('[Login] Starting login...')
        const response: ApiResponse<LoginResponse> = await authService.login(credentials)

        console.log('[Login] Response received:', {
          hasData: !!response.data,
          hasAccessToken: !!response.data?.accessToken,
          hasUser: !!response.data?.user
        })

        // ✅ CRITICAL: Check if we got the required data
        if (!response.data?.accessToken || !response.data?.user) {
          console.error('[Login] Missing required data in response:', response)
          throw new Error("Invalid response from server - missing token or user data")
        }

        const { accessToken: token, user } = response.data
        console.log('[Login] Extracted token and user:', {
          tokenLength: token.length,
          userEmail: user.email
        })

        // ✅ Store in sessionStorage with obfuscated keys
        console.log('[Login] Calling storeSession...')
        storeSession(token, user)
        
        // ✅ Update React state
        console.log('[Login] Updating React state...')
        setAccessToken(token)
        setState({
          user,
          isAuthenticated: true,
          isLoading: false,
          error: null,
        })

        console.log('[AuthContext] ✅ Login successful, session stored')

        // ✅ Refresh token is automatically stored in HTTP-only cookie by browser
      } catch (error: any) {
        console.error('[Login] Error occurred:', {
          message: error.message,
          status: error.status,
          errors: error.errors,
          fullError: error
        })
        
        setState({
          user: null,
          isAuthenticated: false,
          isLoading: false,
          error: {
            message: error.message || "Login failed",
            status: error.status || 0,
            errors: error.errors,
          },
        })
        throw error
      }
    },
    [storeSession]
  )

  // Register handler
  const register = useCallback(
    async (userData: RegisterRequest) => {
      setState((prev) => ({ ...prev, isLoading: true, error: null }))

      try {
        const response: ApiResponse<RegisterResponse> = await authService.register(userData)

        // ✅ Store in sessionStorage with obfuscated keys
        if (response.data?.accessToken && response.data?.user) {
          storeSession(response.data.accessToken, response.data.user)
          setAccessToken(response.data.accessToken)
        }

        setState({
          user: response.data?.user || null,
          isAuthenticated: true,
          isLoading: false,
          error: null,
        })
      } catch (error: any) {
        setState({
          user: null,
          isAuthenticated: false,
          isLoading: false,
          error: {
            message: error.message || "Registration failed",
            status: error.status || 0,
            errors: error.errors,
          },
        })
        throw error
      }
    },
    [storeSession]
  )

  // Logout handler
  const logout = useCallback(async () => {
    setState((prev) => ({ ...prev, isLoading: true }))

    try {
      await authService.logout()
    } catch (error) {
      console.error("Logout error:", error)
    } finally {
      // ✅ Clear session from sessionStorage
      clearSession()
      setAccessToken(null)
      
      setState({
        user: null,
        isAuthenticated: false,
        isLoading: false,
        error: null,
      })

      // Redirect to login page
      router.push("/auth/login")
    }
  }, [router, clearSession])

  // Refresh auth state (useful after token refresh)
  const refreshAuth = useCallback(async () => {
    try {
      const response = await authService.refreshToken()
      
      // ✅ Update sessionStorage and memory
      if (response.data?.accessToken && response.data?.user) {
        storeSession(response.data.accessToken, response.data.user)
        setAccessToken(response.data.accessToken)
      }
      
      setState({
        user: response.data?.user || null,
        isAuthenticated: true,
        isLoading: false,
        error: null,
      })
    } catch (error: any) {
      // ✅ Clear session on refresh failure
      clearSession()
      setAccessToken(null)
      
      setState({
        user: null,
        isAuthenticated: false,
        isLoading: false,
        error: {
          message: error.message || "Failed to refresh authentication",
          status: error.status || 0,
        },
      })
    }
  }, [storeSession, clearSession])

  // Clear error
  const clearError = useCallback(() => {
    setState((prev) => ({ ...prev, error: null }))
  }, [])

  // Expose accessToken getter/setter for axios interceptor
  useEffect(() => {
    // Store getter/setter functions for axios to access token from sessionStorage
    if (typeof window !== 'undefined') {
      const win = window as any;
      win.__getAccessToken = () => {
        // Try memory first, then sessionStorage
        return accessToken || sessionStorage.getItem(TOKEN_KEY);
      };
      win.__setAccessToken = (token: string | null) => {
        setAccessToken(token);
        if (token) {
          sessionStorage.setItem(TOKEN_KEY, token);
        } else {
          sessionStorage.removeItem(TOKEN_KEY);
        }
      };
    }
  }, [accessToken])

  const value: AuthContextType = {
    ...state,
    login,
    register,
    logout,
    refreshAuth,
    clearError,
    setAccessToken,
  }

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>
}

// Custom hook to use auth context
export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error("useAuth must be used within AuthProvider")
  }
  return context
}

export default AuthContext
